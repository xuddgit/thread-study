    1.概述
    队列同步器AbstractQueueSynchronizer(同步器),是用来构建锁或者其他同步组件的基础框架,
    它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者
    （Doug Lea）期望它能够成为实现大部分同步需求的基础。
    同步器的主要使用方式是继承，子类通过继承同步器实并实现它的抽象方法来管理同步状态，
    在抽象的方法实现过程中免不了要对同步状态进行更改，这时就要使用同步器提供的3个方法
    （getState(),setState(int newState),和compareAndSetState(int expect,int update)）
    来进行操作，因为它们能够保证状态的改变时安全的。子类推荐被定义为自定义同步组件的静态内部
    类，同步器自身没有实现任何同步接口，它仅仅时定义了若干同步状态获取，和释放的方法来供自定义同步组件使用
    ，同步器既可以支持独占式的获取同步状态，也可以支持共享式的获取同步状态，这样就可以方便实现不同类型的
    同步组件（ReentrantLock,ReentrantReadWriteLock和CountDownLatch等）

    同步器时实现锁（也可以时任务同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现
    锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁的交互的接口
    （比如可以运行两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了
    锁的实现方式，屏蔽了同步状态管理，线程的排队，等待与幻想底层操作。锁和同步器很好的隔离了使用者
    和实现者所需要关注的领域。
    2.同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，
    随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法
    将会调用使用者重写的方法。
    
    重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步器状态。
    getState();获取当前状态
    setState(int newState);设置当前同步状态
    compareAndSetState(int expect,int update);使用CAS设置当前状态，该方法能够保证状态
    设置的原子性